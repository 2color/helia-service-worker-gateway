diff --git a/node_modules/libp2p/dist/src/connection-manager/auto-dialler.d.ts b/node_modules/libp2p/dist/src/connection-manager/auto-dialler.d.ts
index aaf3108..e343071 100644
--- a/node_modules/libp2p/dist/src/connection-manager/auto-dialler.d.ts
+++ b/node_modules/libp2p/dist/src/connection-manager/auto-dialler.d.ts
@@ -2,6 +2,7 @@ import type { Startable } from '@libp2p/interfaces/startable';
 import type { PeerId } from '@libp2p/interface-peer-id';
 import type { ConnectionManager } from '@libp2p/interface-connection-manager';
 import type { PeerStore } from '@libp2p/interface-peer-store';
+import type { Connection } from '@libp2p/interface-connection';
 export interface AutoDiallerInit {
     /**
      * The minimum number of connections to avoid pruning
@@ -22,6 +23,8 @@ export declare class AutoDialler implements Startable {
     private readonly options;
     private running;
     private autoDialTimeout?;
+    private readonly abortController?;
+    connectionMap: Map<string, Promise<Connection>>;
     /**
      * Proactively tries to connect to known peers stored in the PeerStore.
      * It will keep the number of connections below the upper limit and sort
diff --git a/node_modules/libp2p/dist/src/connection-manager/auto-dialler.d.ts.map b/node_modules/libp2p/dist/src/connection-manager/auto-dialler.d.ts.map
index 912c429..5cfaa0a 100644
--- a/node_modules/libp2p/dist/src/connection-manager/auto-dialler.d.ts.map
+++ b/node_modules/libp2p/dist/src/connection-manager/auto-dialler.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"auto-dialler.d.ts","sourceRoot":"","sources":["../../../src/connection-manager/auto-dialler.ts"],"names":[],"mappings":"AAIA,OAAO,KAAK,EAAE,SAAS,EAAE,MAAM,8BAA8B,CAAA;AAC7D,OAAO,KAAK,EAAE,MAAM,EAAE,MAAM,2BAA2B,CAAA;AACvD,OAAO,KAAK,EAAE,iBAAiB,EAAE,MAAM,sCAAsC,CAAA;AAC7E,OAAO,KAAK,EAAE,SAAS,EAAE,MAAM,8BAA8B,CAAA;AAI7D,MAAM,WAAW,eAAe;IAC9B;;OAEG;IACH,cAAc,CAAC,EAAE,MAAM,CAAA;IAEvB;;OAEG;IACH,gBAAgB,CAAC,EAAE,MAAM,CAAA;CAC1B;AAED,MAAM,WAAW,qBAAqB;IACpC,MAAM,EAAE,MAAM,CAAA;IACd,iBAAiB,EAAE,iBAAiB,CAAA;IACpC,SAAS,EAAE,SAAS,CAAA;CACrB;AAOD,qBAAa,WAAY,YAAW,SAAS;IAC3C,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAuB;IAClD,OAAO,CAAC,QAAQ,CAAC,OAAO,CAA2B;IACnD,OAAO,CAAC,OAAO,CAAS;IACxB,OAAO,CAAC,eAAe,CAAC,CAAqB;IAE7C;;;;OAIG;gBACU,UAAU,EAAE,qBAAqB,EAAE,IAAI,EAAE,eAAe;IASrE,SAAS,IAAK,OAAO;IAIrB;;OAEG;IACG,KAAK,IAAK,OAAO,CAAC,IAAI,CAAC;IAU7B;;OAEG;IACG,IAAI,IAAK,OAAO,CAAC,IAAI,CAAC;IAUtB,SAAS,IAAK,OAAO,CAAC,IAAI,CAAC;CAyElC"}
\ No newline at end of file
+{"version":3,"file":"auto-dialler.d.ts","sourceRoot":"","sources":["../../../src/connection-manager/auto-dialler.ts"],"names":[],"mappings":"AAIA,OAAO,KAAK,EAAE,SAAS,EAAE,MAAM,8BAA8B,CAAA;AAC7D,OAAO,KAAK,EAAE,MAAM,EAAE,MAAM,2BAA2B,CAAA;AACvD,OAAO,KAAK,EAAE,iBAAiB,EAAE,MAAM,sCAAsC,CAAA;AAC7E,OAAO,KAAK,EAAE,SAAS,EAAE,MAAM,8BAA8B,CAAA;AAE7D,OAAO,KAAK,EAAE,UAAU,EAAE,MAAM,8BAA8B,CAAA;AAI9D,MAAM,WAAW,eAAe;IAC9B;;OAEG;IACH,cAAc,CAAC,EAAE,MAAM,CAAA;IAEvB;;OAEG;IACH,gBAAgB,CAAC,EAAE,MAAM,CAAA;CAC1B;AAED,MAAM,WAAW,qBAAqB;IACpC,MAAM,EAAE,MAAM,CAAA;IACd,iBAAiB,EAAE,iBAAiB,CAAA;IACpC,SAAS,EAAE,SAAS,CAAA;CACrB;AAOD,qBAAa,WAAY,YAAW,SAAS;IAC3C,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAuB;IAClD,OAAO,CAAC,QAAQ,CAAC,OAAO,CAA2B;IACnD,OAAO,CAAC,OAAO,CAAS;IACxB,OAAO,CAAC,eAAe,CAAC,CAAqB;IAC7C,OAAO,CAAC,QAAQ,CAAC,eAAe,CAAC,CAAY;IAC7C,aAAa,EAAE,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC,UAAU,CAAC,CAAC,CAAA;IAE/C;;;;OAIG;gBACU,UAAU,EAAE,qBAAqB,EAAE,IAAI,EAAE,eAAe;IAWrE,SAAS,IAAK,OAAO;IAIrB;;OAEG;IACG,KAAK,IAAK,OAAO,CAAC,IAAI,CAAC;IAU7B;;OAEG;IACG,IAAI,IAAK,OAAO,CAAC,IAAI,CAAC;IAYtB,SAAS,IAAK,OAAO,CAAC,IAAI,CAAC;CA6FlC"}
diff --git a/node_modules/libp2p/dist/src/connection-manager/auto-dialler.js b/node_modules/libp2p/dist/src/connection-manager/auto-dialler.js
index ce1cc32..f49c0fb 100644
--- a/node_modules/libp2p/dist/src/connection-manager/auto-dialler.js
+++ b/node_modules/libp2p/dist/src/connection-manager/auto-dialler.js
@@ -2,6 +2,7 @@ import { logger } from '@libp2p/logger';
 import mergeOptions from 'merge-options';
 // @ts-expect-error retimer does not have types
 import retimer from 'retimer';
+import AbortAbort from 'abortabort';
 const log = logger('libp2p:connection-manager:auto-dialler');
 const defaultOptions = {
     minConnections: 0,
@@ -18,6 +19,9 @@ export class AutoDialler {
         this.options = mergeOptions.call({ ignoreUndefined: true }, defaultOptions, init);
         this.running = false;
         this._autoDial = this._autoDial.bind(this);
+        this.abortController = new AbortAbort();
+        this.connectionMap = new Map();
+        this.peerQualityMap = new Map();
         log('options: %j', this.options);
     }
     isStarted() {
@@ -29,7 +33,7 @@ export class AutoDialler {
     async start() {
         this.running = true;
         void this._autoDial().catch(err => {
-            log.error('could start autodial', err);
+            log.error('could not start autodial', err);
         });
         log('started');
     }
@@ -38,6 +42,8 @@ export class AutoDialler {
      */
     async stop() {
         this.running = false;
+        // This will cause all pending dials to be aborted as well.
+        this.abortController?.abort();
         if (this.autoDialTimeout != null) {
             this.autoDialTimeout.clear();
         }
@@ -47,6 +53,8 @@ export class AutoDialler {
         if (this.autoDialTimeout != null) {
             this.autoDialTimeout.clear();
         }
+        const numOpenDialAttempts = this.connectionMap.size;
+        log('auto dialing, open dial attempts: %d', numOpenDialAttempts);
         const minConnections = this.options.minConnections;
         // Already has enough connections
         if (this.components.connectionManager.getConnections().length >= minConnections) {
@@ -66,7 +74,12 @@ export class AutoDialler {
             }
             return true;
         });
-        // shuffle the peers
+        /**
+         * shuffle the peers
+         *
+         * todo: Be smarter about shuffling peers. We should add weights to peers
+         * that are more likely to succeed
+         */
         peers = peers.sort(() => Math.random() > 0.5 ? 1 : -1);
         peers = peers.sort((a, b) => {
             // dial peers with the most protocols first
@@ -85,14 +98,46 @@ export class AutoDialler {
                 return;
             }
             const peer = peers[i];
-            if (this.components.connectionManager.getConnections(peer.id).length === 0) {
+            const peerIdString = peer.id.toString();
+            let peerQuality = this.peerQualityMap.get(peerIdString);
+            if (peerQuality == null) {
+              peerQuality = {
+                attempts: 1,
+                success: 0
+              };
+            } else if (peerQuality.attempts > 10 && peerQuality.success / peerQuality.attempts <= 0.5 ) {
+              // We have tried to connect to this peer too many times
+              log.warn(`peer ${peerIdString} has failed to connect too many times (${peerQuality.success}/${peerQuality.attempts}), skipping`)
+              continue;
+            } else {
+              log('peer %s has %d/%d successful dial attempts', peerIdString, peerQuality.success, peerQuality.attempts)
+            }
+            if (this.components.connectionManager.getConnections(peer.id).length === 0 && !this.connectionMap.has(peerIdString)) {
                 log('connecting to a peerStore stored peer %p', peer.id);
-                try {
-                    await this.components.connectionManager.openConnection(peer.id);
-                }
-                catch (err) {
+                const connectionAbortController = new AbortAbort();
+                this.abortController?.addDependant(connectionAbortController);
+                /**
+                 * we do not need to await the connection attempts because we are
+                 * blocking new calls to `openConnection` by checking whether the
+                 * peer already has an attempt in the `connectionMap` and we are
+                 * removing the peer from the `connectionMap` when the attempt
+                 * finishes (successful or not)
+                 */
+                const connectionAttempt = this.components.connectionManager.openConnection(peer.id, { signal: connectionAbortController.signal });
+                connectionAttempt.then((connection) => {
+                    peerQuality.success++;
+                    return connection
+                });
+                connectionAttempt.catch((err) => {
                     log.error('could not connect to peerStore stored peer', err);
-                }
+                });
+                this.connectionMap.set(peerIdString, connectionAttempt);
+                connectionAttempt.finally(() => {
+                    this.connectionMap.delete(peerIdString);
+                    connectionAbortController.abort();
+                    peerQuality.attempts++;
+                    this.peerQualityMap.set(peerIdString, peerQuality);
+                });
             }
         }
         // Connection Manager was stopped
diff --git a/node_modules/libp2p/dist/src/connection-manager/auto-dialler.js.map b/node_modules/libp2p/dist/src/connection-manager/auto-dialler.js.map
index 9fd7b28..77107bb 100644
--- a/node_modules/libp2p/dist/src/connection-manager/auto-dialler.js.map
+++ b/node_modules/libp2p/dist/src/connection-manager/auto-dialler.js.map
@@ -1 +1 @@
-{"version":3,"file":"auto-dialler.js","sourceRoot":"","sources":["../../../src/connection-manager/auto-dialler.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"auto-dialler.js","sourceRoot":"","sources":["../../../src/connection-manager/auto-dialler.ts"],"names":[],"mappings":"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"}
diff --git a/node_modules/libp2p/dist/src/connection-manager/dialer/index.js b/node_modules/libp2p/dist/src/connection-manager/dialer/index.js
index 4078965..85533b6 100644
--- a/node_modules/libp2p/dist/src/connection-manager/dialer/index.js
+++ b/node_modules/libp2p/dist/src/connection-manager/dialer/index.js
@@ -67,6 +67,7 @@ export class DefaultDialer {
         const { peerId, multiaddr } = getPeerAddress(peerIdOrMultiaddr);
         if (peerId != null) {
             if (this.components.peerId.equals(peerId)) {
+              log('tried to dial self');
                 throw new CodeError('Tried to dial self', codes.ERR_DIALED_SELF);
             }
             if (multiaddr != null) {
@@ -74,6 +75,7 @@ export class DefaultDialer {
                 await this.components.peerStore.addressBook.add(peerId, [multiaddr]);
             }
             if ((await this.components.connectionGater.denyDialPeer?.(peerId)) === true) {
+                log('dial request blocked by gater.denyDialPeer %p', peerId);
                 throw new CodeError('The dial request is blocked by gater.allowDialPeer', codes.ERR_PEER_DIAL_INTERCEPTED);
             }
         }
@@ -99,6 +101,7 @@ export class DefaultDialer {
             this.pendingDialTargets.delete(controllerId);
         }
         if (dialTarget.addrs.length === 0) {
+            log('no valid addresses for %p', peerId);
             throw new CodeError('The dial request has no valid addresses', codes.ERR_NO_VALID_ADDRESSES);
         }
         // try to join an in-flight dial for this peer if one is available
@@ -138,6 +141,9 @@ export class DefaultDialer {
         }
         return this.pendingDials.has(peerId.toString());
     }
+
+    // prevent all the work in _createDialTarget from being repeated for successive dials to the same peer/multiaddr
+    // dialTargetCache = new Map();
     /**
      * Creates a DialTarget. The DialTarget is used to create and track
      * the DialRequest to a given peer.
@@ -147,23 +153,32 @@ export class DefaultDialer {
      * Multiaddrs not supported by the available transports will be filtered out.
      */
     async _createDialTarget(peerIdOrMultiaddr, options) {
+      // const cacheKey = `${peerIdOrMultiaddr.peerId?.toString()}-${peerIdOrMultiaddr.multiaddr?.toString()}-${options?.signal != null ? 1 : 0}`
+        // if (this.dialTargetCache.has(cacheKey)) {
+        //   return this.dialTargetCache.get(cacheKey);
+        // }
         let addrs = [];
         if (isMultiaddr(peerIdOrMultiaddr.multiaddr)) {
+          log('Passed multiaddr %s', peerIdOrMultiaddr.multiaddr.toString())
             addrs.push(peerIdOrMultiaddr.multiaddr);
         }
         // only load addresses if a peer id was passed, otherwise only dial the passed multiaddr
         if (!isMultiaddr(peerIdOrMultiaddr.multiaddr) && isPeerId(peerIdOrMultiaddr.peerId)) {
+          log('Passed peerId %s', peerIdOrMultiaddr.peerId.toString())
             addrs.push(...await this._loadAddresses(peerIdOrMultiaddr.peerId));
         }
         addrs = (await Promise.all(addrs.map(async (ma) => await this._resolve(ma, options))))
             .flat();
+        log(`addrs.length: `, addrs.length);
+        log(`addresses: %s`, addrs.map(ma => ma.toString()).join(', '));
         // Multiaddrs not supported by the available transports will be filtered out.
         const filteredAddrs = addrs.filter(ma => Boolean(this.components.transportManager.transportForMultiaddr(ma)));
+        log('addresses after filtering', filteredAddrs.map(ma => ma.toString()));
         // deduplicate addresses
         const dedupedAddrs = [...new Set(filteredAddrs.map(ma => ma.toString()))];
         let dedupedMultiaddrs = dedupedAddrs.map(ma => multiaddr(ma));
+        log('addresses after deduping', dedupedMultiaddrs.map(ma => ma.toString()));
         if (dedupedMultiaddrs.length > this.maxAddrsToDial) {
-            log('addresses after filtering', dedupedMultiaddrs.map(ma => ma.toString()));
             throw new CodeError('dial with more addresses than allowed', codes.ERR_TOO_MANY_ADDRESSES);
         }
         if (dedupedMultiaddrs.length === 0) {
@@ -186,16 +201,24 @@ export class DefaultDialer {
                 return addr;
             });
         }
-        return {
+        // TODO: overwrite multiaddrs in peerStore.addressBook with the deduped Multiaddrs if we have a valid peerId
+        // if (peerId != null) {
+        //     await this.components.peerStore.addressBook.set(peerId, dedupedMultiaddrs);
+        // }
+
+        const dialTargetResult = {
             id: peerId == null ? randomId() : peerId.toString(),
             addrs: dedupedMultiaddrs
         };
+        // this.dialTargetCache.set(cacheKey, dialTargetResult);
+        return dialTargetResult;
     }
     /**
      * Loads a list of addresses from the peer store for the passed peer id
      */
     async _loadAddresses(peer) {
         const addresses = await this.components.peerStore.addressBook.get(peer);
+        console.log(`_loadAddresses addresses: `, addresses);
         return (await Promise.all(addresses.map(async (address) => {
             const deny = await this.components.connectionGater.denyDialMultiaddr?.(peer, address.multiaddr);
             if (deny === true) {
diff --git a/node_modules/libp2p/dist/src/connection-manager/index.js b/node_modules/libp2p/dist/src/connection-manager/index.js
index 98632ee..eced81c 100644
--- a/node_modules/libp2p/dist/src/connection-manager/index.js
+++ b/node_modules/libp2p/dist/src/connection-manager/index.js
@@ -236,13 +236,18 @@ export class DefaultConnectionManager extends EventEmitter {
         const peerIdStr = peerId.toString();
         const storedConns = this.connections.get(peerIdStr);
         if (storedConns != null) {
+          log('adding connection to existing peer %s', peerIdStr)
             storedConns.push(connection);
         }
         else {
+          log('adding connection to new peer %s', peerIdStr)
             this.connections.set(peerIdStr, [connection]);
         }
         if (peerId.publicKey != null) {
+          log('setting public key for peer %s', peerIdStr)
             await this.components.peerStore.keyBook.set(peerId, peerId.publicKey);
+        } else {
+          log('no public key for peer %s', peerIdStr)
         }
         const numConnections = this.getConnections().length;
         const toPrune = numConnections - this.opts.maxConnections;
@@ -285,6 +290,7 @@ export class DefaultConnectionManager extends EventEmitter {
     async openConnection(peerIdOrMultiaddr, options = {}) {
         const { peerId, multiaddr } = getPeerAddress(peerIdOrMultiaddr);
         if (peerId == null && multiaddr == null) {
+            log('openConnection: peerIdOrMultiaddr is neither a PeerId nor a Multiaddr', peerIdOrMultiaddr.toString())
             throw new CodeError('Can only open connections to PeerIds or Multiaddrs', codes.ERR_INVALID_PARAMETERS);
         }
         if (peerId != null) {
@@ -325,6 +331,25 @@ export class DefaultConnectionManager extends EventEmitter {
                 peerConnections.push(connection);
             }
             return connection;
+        } catch (err) {
+            // if (err.code === codes.ERR_CONNECTION_LIMIT_REACHED) {
+            //   log.error(`connection limit reached for peer ${peerIdOrMultiaddr.toString()}`, err)
+            //     throw err;
+            // }
+            // if (err.code === codes.ERR_CONNECTION_FAILED) {
+            //   log.error('connection failed', err)
+            //     throw err;
+            // }
+            // if (err.code === codes.ERR_CONNECTION_DIAL_FAILED) {
+            //   log.error('connection dial failed', err)
+            //     throw err;
+            // }
+            // if (err.code === codes.ERR_CONNECTION_DIAL_ABORTED) {
+            //   log.error('connection dial aborted', err)
+            //     throw err;
+            // }
+            log.error(`failed to dial to peer ${peerIdOrMultiaddr.toString()}`, err)
+            throw new CodeError('Failed to dial to peer', codes.ERR_CONNECTION_DIAL_FAILED, err);
         }
         finally {
             if (timeoutController != null) {
@@ -368,11 +393,15 @@ export class DefaultConnectionManager extends EventEmitter {
      */
     async _checkMaxLimit(name, value, toPrune = 1) {
         const limit = this.opts[name];
-        if (limit == null) {
+        if (limit == null) { // does not catch the NaN case.
             log.trace('limit %s was not set so it cannot be applied', name);
             return;
         }
-        log.trace('checking limit of %s. current value: %d of %d', name, value, limit);
+        if (limit === Infinity) {
+            log.trace('limit %s is Infinity so it cannot be applied', name);
+            return;
+        }
+        log.trace('checking limit of %s. current value: %d of %d', name, value, limit === Infinity ? 'Infinity' : limit);
         if (value > limit) {
             log('%s: limit exceeded: %p, %d/%d, pruning %d connection(s)', this.components.peerId, name, value, limit, toPrune);
             await this._pruneConnections(toPrune);
diff --git a/node_modules/libp2p/dist/src/content-routing/utils.js b/node_modules/libp2p/dist/src/content-routing/utils.js
index 13f3b78..72117a7 100644
--- a/node_modules/libp2p/dist/src/content-routing/utils.js
+++ b/node_modules/libp2p/dist/src/content-routing/utils.js
@@ -36,7 +36,7 @@ export async function* requirePeers(source, min = 1) {
         yield peer;
     }
     if (seen < min) {
-        throw new CodeError('not found', 'NOT_FOUND');
+        throw new CodeError(`requirePeers failed with ${seen} of ${min} required peers.`, 'NOT_FOUND');
     }
 }
 //# sourceMappingURL=utils.js.map
